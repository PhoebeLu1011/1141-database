<!doctype html>
<html lang="zh-Hant">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>旅行紀錄地圖</title>
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css">
  <style>
    html, body, #map { height: 100%; margin: 0; }
    .panel { position: absolute; top: 10px; left: 10px; z-index: 1000; background: #fff; padding: 10px; border-radius: 10px; box-shadow: 0 2px 10px rgba(0,0,0,.15); }
    .panel input, .panel textarea { width: 230px; margin: 4px 0; }
    .hint { font-size: 12px; color: #666; }
    .danger { color: #b71c1c; }
  </style>
</head>
<body>
  <div id="map"></div>
  <div class="panel">
    <strong>新增紀錄</strong>
    <div class="hint">點地圖會放一顆「暫存標記」，可拖曳後再儲存</div>
    <div>座標：<span id="coords">未選</span></div>
    <input id="title" placeholder="標題">
    <textarea id="notes" rows="3" placeholder="心得"></textarea>
    <input id="photo" placeholder="照片網址（選填）">
    <div>
      <button id="save">儲存</button>
      <button id="clearTemp" type="button">清除暫存</button>
    </div>
    <hr/>
    <button id="near">查詢附近 3km</button>
  </div>

  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
  <script>
    const API = "/api/entries";

    const map = L.map("map").setView([25.034, 121.5645], 12);
    L.tileLayer("https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png", { maxZoom: 19 }).addTo(map);

    let tempMarker = null; // 暫存（尚未寫 DB）
    const coordsEl = document.getElementById("coords");

    // 已儲存 marker 集合，避免重複渲染
    const liveMarkers = {}; // key: _id → value: Leaflet marker

    function setTempMarker(latlng) {
      if (tempMarker) map.removeLayer(tempMarker);
      tempMarker = L.marker(latlng, { draggable: true }).addTo(map);
      coordsEl.textContent = `${latlng.lat.toFixed(6)}, ${latlng.lng.toFixed(6)}`;
      tempMarker.on("dragend", () => {
        const p = tempMarker.getLatLng();
        coordsEl.textContent = `${p.lat.toFixed(6)}, ${p.lng.toFixed(6)}`;
      });
    }

    map.on("click", (e) => setTempMarker(e.latlng));

    document.getElementById("clearTemp").addEventListener("click", () => {
      if (tempMarker) {
        map.removeLayer(tempMarker);
        tempMarker = null;
        coordsEl.textContent = "未選";
      }
    });

    async function fetchByBbox() {
      const b = map.getBounds();
      const bbox = [b.getWest(), b.getSouth(), b.getEast(), b.getNorth()].join(",");
      const res = await fetch(`${API}?bbox=${bbox}`);
      const data = await res.json();
      renderMarkers(data);
    }

    function attachSavedMarkerBehaviors(marker, item) {
      // 拖曳 → PATCH 更新座標
      marker.dragging.enable();
      marker.on("dragend", async () => {
        const p = marker.getLatLng();
        const res = await fetch(`${API}/${item._id}`, {
          method: "PATCH",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({ lng: p.lng, lat: p.lat })
        });
        if (!res.ok) {
          alert("移動失敗，已復原位置");
          marker.setLatLng([item.location.coordinates[1], item.location.coordinates[0]]);
          return;
        }
        const updated = await res.json();
        item.location.coordinates = updated.location.coordinates; // 同步本地
      });

      // 右鍵刪除（手機可長按呼叫 contextmenu；或改為在 popup 內放刪除鈕）
      marker.on("contextmenu", async () => {
        if (!confirm(`刪除「${item.title}」？`)) return;
        const res = await fetch(`${API}/${item._id}`, { method: "DELETE" });
        if (res.ok) {
          map.removeLayer(marker);
          delete liveMarkers[item._id];
        } else {
          alert("刪除失敗");
        }
      });
    }

    function renderMarkers(items) {
      const seen = new Set();
      items.forEach(item => {
        const id = item._id;
        seen.add(id);
        if (liveMarkers[id]) return; // 已存在就不重畫
        const [lng, lat] = item.location.coordinates;
        const m = L.marker([lat, lng], { draggable: true }).addTo(map);
        const html = `
          <b>${item.title}</b><br/>
          <small>${new Date(item.date || item.createdAt).toLocaleString()}</small><br/>
          ${item.notes ? `<div>${item.notes}</div>` : ""}
          ${item.photos?.[0] ? `<img src="${item.photos[0]}" style="max-width:160px; margin-top:6px;"/>` : ""}
          <div class="hint">提示：拖曳可移動，右鍵可刪除</div>
        `;
        m.bindPopup(html);
        attachSavedMarkerBehaviors(m, item);
        liveMarkers[id] = m;
      });

      // （可選）清除已不在結果中的 marker
      Object.keys(liveMarkers).forEach(id => {
        if (!seen.has(id)) {
          map.removeLayer(liveMarkers[id]);
          delete liveMarkers[id];
        }
      });
    }

    document.getElementById("save").addEventListener("click", async () => {
      if (!tempMarker) return alert("請先在地圖上點一個位置");
      const title = document.getElementById("title").value.trim();
      if (!title) return alert("請輸入標題");
      const notes = document.getElementById("notes").value.trim();
      const photo = document.getElementById("photo").value.trim();

      const p = tempMarker.getLatLng();
      const res = await fetch(API, {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({
          title,
          notes,
          photos: photo ? [photo] : [],
          lng: p.lng,
          lat: p.lat
        })
      });
      if (!res.ok) return alert("儲存失敗");
      const saved = await res.json();
      // 清掉暫存並補畫新資料
      if (tempMarker) { map.removeLayer(tempMarker); tempMarker = null; coordsEl.textContent = "未選"; }
      renderMarkers([saved]);
      alert("已新增！");
    });

    document.getElementById("near").addEventListener("click", async () => {
      if (!navigator.geolocation) return alert("無定位權限");
      navigator.geolocation.getCurrentPosition(async (pos) => {
        const { latitude, longitude } = pos.coords;
        map.setView([latitude, longitude], 14);
        const res = await fetch(`/api/entries/near?lng=${longitude}&lat=${latitude}&maxDistance=3000`);
        const data = await res.json();
        renderMarkers(data);
      }, () => alert("定位失敗或被拒絕"));
    });

    map.on("moveend", fetchByBbox);
    fetchByBbox();
  </script>
</body>
</html>